;****************************************************************************
;*								$$$$$$$$$$$$$$ 	                        	*
;*								$	TEXvid   $								*
;*								$$$$$$$$$$$$$$								*
;*			 			Sistema de interface ....							*
;*																			*
;*			   		Desenvolvido por Ricardo de Azambuja					*
;*																			*
;*		main.asm															*
;*		Versão 0.1							Data Inicial: 13/10/2005		*
;*--------------------------------------------------------------------------*
;* DESCRIÇÃO DO ARQUIVO / PROJETO:											*
;* -																		*
;* -																		*
;* - 																		*
;* - 																		*
;* - 																		*
;*--------------------------------------------------------------------------*
;* NOTAS:																	*
;* 1)PINOS UTILIZADOS:
;* -RA6 E RA7 (OSC EXTERNO);RB1 E RB2 (USART ASSÍNCRONA)
;* -RA2 (SAÍDA DO VÍDEO COMPOSTO)									        *
;* -RA1 (LED INDICADOR DE ERRO NA SERIAL)
;* -Criar arquivos para as MACROS genéricas e específicas a este programa   *
;* depois é só usar um #INCLUDE <MINHASMACROS.MAC>																			*
;****************************************************************************

;****************************************************************************
;*							ARQUIVOS DE DEFINIÇÕES							*
;****************************************************************************

#INCLUDE <P16F628.inc>       ; processor specific variable definitions



;	__CONFIG   _CP_OFF & _DATA_CP_OFF & _LVP_OFF & _BOREN_ON & _MCLRE_OFF & _WDT_OFF & _PWRTE_ON & _HS_OSC
; Ver livro Desbravando o PIC pág 62 para as configurações

;****************************************************************************
;*							PAGINAÇÃO DE MEMÓRIA							*
;****************************************************************************
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE		BANK0	BCF STATUS,RP0 ;SETA BANK 0 DE MEMÓRIA
#DEFINE		BANK1	BSF	STATUS,RP0 ;SETA BANK 1 DE MEMÓRIA

;A diretriz #DEFINE substitui nomes por expressões inteiras
;(a diretriz EQU substitui nomes por números)



;****************************************************************************
;*								VARIÁVEIS									*
;****************************************************************************
;DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS PELO SISTEMA
;NÃO ESQUECER QUE TODAS ESSAS VARIÁVEIS SERÃO DE 8BITS

	CBLOCK		0x20				;ENDEREÇO INICIAL DA MEMÓRIA DE USUÁRIO
				W_TEMP				;REGISTRADORES TEMPORÁRIOS PARA USO
				STATUS_TEMP			;JUNTO ÀS INTERRUPÇÕES
				;AQUI IRÃO AS NOVAS VARIÁVEIS
				CONTADORLED_OERR	;Contador usado para manter o led aceso por algum tempo

	ENDC						;FIM DO BLOCO DE MEMÓRIA

;CBLOCK e ENDC: é uma maneira simplificada de definirmos vários EQUs com 
;endereços sequenciais. Assim fica mais fácil a migração para outro processador ou
;para outro bloco de endereços.



;****************************************************************************
;*							FLAGS INTERNOS									*
;****************************************************************************
;DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA



;****************************************************************************
;*								CONSTANTES									*
;****************************************************************************
;DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA

INIC_TMR0 		EQU		.0			;Inicializa o TMR0



;****************************************************************************
;*								MACROS     									*
;****************************************************************************

;Esta macro foi necessária para facilitar a manutenção do código fonte.
;Sem uma macro, esse conjunto de instruções seria repetido para cada bit lido
;tornando o arquivo fonte ilegível para o programador.
;
;
;SAIDABIT
;Gera o código necessário para a leitura de um bit da memória RAM
;e posterior escrita no pino definido por saida.
; - ENDERECO_INI: endereço inicial da RAM onde esta a linha que será lida.
; - ENDERECO_FIN: endereço final.
; - NBIT    : número de bits a serem lidos no total (assim não preciso ler bytes inteiros)
; - ROTULO  : rótulo inicial para servir como endereço base na memória de programa.
SAIDABIT	MACRO	ENDERECO_INI, ENDERECO_FIN, NBIT, ROTULO
				VARIABLE	i=0						;define uma variável para o compilador
													;NÃO ESTARÁ PRESENTE NO ASSEMBLY!
				VARIABLE	ENDERECO=ENDERECO_INI
				WHILE ENDERECO<=ENDERECO_FIN
				WHILE i<NBIT
					btfss		ENDERECO,i
					addwf		PCL,1				;Tem o mesmo efeito do goto, mas com uma única instrução	
					bsf			saida				;Seta o pino de saída pra 1
					goto		ROTULO+(7*(i+1))	;"Mágica" usada para pular para as linhas corretas 
													;usando o endereço inicial passado para a macro na forma de rótulo
					bcf			saida				;Seta o pino de saída pra 0
					nop
					nop								;Se vc não sabe o que isso significa...
				i+=1
				ENDW ;fim do segundo while
				i=0
				ENDERECO+=1
				ENDW ;fim do primeiro while
			ENDM


;****************************************************************************
;*								ENTRADAS									*
;****************************************************************************
;DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
;COM OS SEUS ESTADOS COMENTADOS (0 E 1)


;****************************************************************************
;*									SAÍDAS									*
;****************************************************************************
;DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
;RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

#DEFINE			saida		PORTA,2		;A princípio, esta será a saída de vídeo RA2
										;- 1 para branco
										;- 0 para preto
										;- alta impedância para sincronismo
										;*para o sincronismo deve-se mudar no TRISA

#DEFINE			LED_OERR	PORTA,1		;Define o pino do led que indicará o erro no recebimento
										;da serial.										
										;- 1 apagado (normal)
										;- 0 aceso (erro overrun no recebimento)


;****************************************************************************
;*								VETOR DE RESET								*
;****************************************************************************
	ORG 		0x00				;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO 		INICIO



;****************************************************************************
;*						INÍCIO DAS INTERRUPÇÕES								*
;****************************************************************************
;ENDEREÇOS DE DESVIO DAS INTERRUPÇÕES, A PRIMEIRA TAREFA É SALVAR OS VALORES
;DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG 		0x04				;ENDEREÇO INICIAL DAS INTERRUPÇÕES
	MOVWF		W_TEMP				;COPIA W PARA W_TEMP
	SWAPF 		STATUS,W
	MOVWF		STATUS_TEMP			;COPIA STATUS PARA STATUS_TEMP
	

;****************************************************************************
;*							ROTINA DE INTERRUPÇÃO							*
;****************************************************************************
;AQUI SERÃO ESCRITAS AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS INTERRUPÇÕES
;No PIC16F628A, para sabermos qual foi a interrupção que ocorreu deve-se fazer
;um tratamento por software (polling).

	btfsc		INTCON,T0IF			;Testa se interrupção foi do TMR0	
	goto		INT_TIMER0

	btfsc		PIR1,RCIF			;Testa se interrupção foi por recebimento serial
	goto		INT_SERIAL

	goto		SAI_INT


;Tratamento da interrupção por estouro do Timer0
INT_TIMER0
	bcf			INTCON,T0IF			;Limpa o bit que foi setado pelo estouro do TMR0
	movlw		INIC_TMR0
	movwf		TMR0				;Recarrega o TMR0

	btfsc		PORTB,7
	goto 		LIMPAR
	goto		SETAR

LIMPAR
	bcf			PORTB,7
	bsf			PORTA,2
	goto		SAI_INT

SETAR
	bsf			PORTB,7
	bcf			PORTA,2
	goto		SAI_INT

;Tratamento da interrupção devido à recepção pela Serial
INT_SERIAL
	bcf    		PIR1,RCIF    		;Clear RCIF Interrupt Flag

	movlw		.0
	movf		RCREG,W

	btfsc		RCSTA,OERR			;Testa se houve erro na recepção (overrun error)
	goto		ERRO_OERR
;Se não ocorreu o erro, devo garantir que o led estará apagado?
;-Não, porque o led inicia apagado e depois o controle se encarrega disso.
	goto		SAI_INT


;Tratamento do Overrun Error e acendimento / apagamento do led indicativo
ERRO_OERR
	bcf			LED_OERR			;Acende o led
;	incfsz		CONTADORLED_OERR	;Incrementa o contador e se for zero apaga o bit OERR
									;e desliga o led indicador.
;	goto		SAI_INT
	
	bcf			RCSTA,CREN			;Desliga o bit OERR (ele é ligado por hardware)
	bcf			RCSTA,CREN			;Note que para desligar o OERR é necessário
									;desligar e ligar o CREN (que ativa o recebimento.

	bsf			LED_OERR			;Desliga o led indicador de erro na serial

	goto 		SAI_INT

	
;Aqui eu deveria ligar o led que indicará esse tipo de erro
;O bit OERR deve ser limpo por software. Preciso implementar um contador
;para garantir que o led ficará tempo suficiente aceso para que um ser humano
;consiga percebê-lo


;****************************************************************************
;*							ROTINA DE SAÍDA DA INTERRUPÇÃO					*
;****************************************************************************
;OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE RETORNAR DA INTERRUPÇÃO

SAI_INT
	SWAPF		STATUS_TEMP,W
	MOVWF		STATUS				;MOVE STATUS_TEMP PARA STATUS
	SWAPF		W_TEMP,F
	SWAPF		W_TEMP,W			;MOVE W_TEMP PARA W
	RETFIE							;RETORNA DA INTERRUPÇÃO (VER ESQUEMA LIVRO PÁG 135)

;OBSERVAÇÕES: 
;- A utilização de SWAPF ao invés de MOVF evita a alteração do STATUS.
;- No início do tratamento da interrupção, a chave geral é desligada automaticamente
;e depois do RETFIE ela é religada.

;****************************************************************************
;*							ROTINAS E SUBROTINAS							*
;****************************************************************************
;CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO E UM
;NOME COERENTE ÀS SUAS FUNÇÕES

SUBROTINA1
	;CORPO DA ROTINA

	RETURN


;****************************************************************************
;*							INÍCIO DO PROGRAMA								*
;****************************************************************************

INICIO
;Limpa a memória RAM a partir do endereço 0x20
;Trecho de código retirado do datasheet PICmicro MID-RANGE MCU FAMILY

;	CLRF 		STATUS 				; Clear STATUS register (Bank0)
;	MOVLW 		0x20 				; 1st address (in bank) of GPR area
;	MOVWF 		FSR		 			; Move it to Indirect address register
;Bank0_LP
;	CLRF 		INDF 				; Clear GPR at address pointed to by FSR
;	INCF 		FSR, 1 				; Next GPR (RAM) address
;	BTFSS 		FSR, 7 				; End of current bank ? (FSR = 80h, C = 0)
;	GOTO 		Bank0_LP 			; NO, clear next location
;
; Next Bank (Bank1)
; (** ONLY REQUIRED IF DEVICE HAS A BANK1 **)
;
;	MOVLW 		0xA0 				; 1st address (in bank) of GPR area
;	MOVWF 		FSR 				; Move it to Indirect address register
;Bank1_LP
;	CLRF 		INDF 				; Clear GPR at address pointed to by FSR
;	INCF 		FSR, 1 				; Next GPR (RAM) address
;	NOP
;	BTFSS 		STATUS, Z 			; End of current bank? (FSR = 00h, Z = 1)
;	GOTO 		Bank1_LP 			; NO, clear next location

;Fim da limpeza da memória
	BANK0							;TROCA PARA O BANCO DE MEMÓRIA 0
	CLRF		PORTA				;LIMPA O PORTA
	CLRF		PORTB				;LIMPA O PORTB


	BANK1							;TROCA PARA O BANCO DE MEMÓRIA 1
	MOVLW		B'00000000'
	MOVWF		TRISA				;DEFINE ENTRADAS E SAÍDAS DO PORT A
	MOVLW		B'00000110'
	MOVWF		TRISB				;DEFINE ENTRADAS E SAÍDAS DO PORT B
									;Bits 1 e 2 referentes a USART
	MOVLW		B'00000000'
	MOVWF		OPTION_REG			;DEFINE OPÇÕES DE OPERAÇÃO
	MOVLW		B'00000000'
	MOVWF		INTCON				;DEFINE OPÇÕES DE INTERRUPÇÕES

;Meu setup
;Aqui são configurados os registrados especiais (SFR) para o funcionamento correto do sistema
;Para mais informações sobre os bits dos SFRs, ver livro pág 193
	BANK0
	movlw		INIC_TMR0
	movwf		TMR0				;Inicializa o TMR0 com 0
	BANK1

	;Setup para recepção pela USART assíncrona.
	;A configuração será feita para 9600-8N1.
	;Baud-Rate 9600, 8 bits de dados, sem paridade e um stop-bit.
	movlw		.129				;Carrega o valor para
	movwf		SPBRG				;setar o BaudRate da USART para 9600.

	bcf			TXSTA, SYNC			;Habilita a Porta Serial Assíncrona
	bsf			TXSTA, BRGH			;Seta para High Speed Baud
	BANK0							;limpando o SYNC e setando o SPEN.
	bsf			RCSTA, SPEN			;
	BANK1
	bsf			PIE1, RCIE			;Habilita a interrupção de recepção
	BANK0
	bcf			RCSTA, RX9D			;Desabilita a recepção de 9bits (usada para o CRC por software).
	bsf			RCSTA, CREN			;Habilita a recepção.
	;Fim do setup da serial


	BANK1
	bcf			OPTION_REG,T0CS 	;Seta o TMR0 para o timer mode - incrementa a cada ciclo de clock
	bsf			OPTION_REG,PSA		;Ativa o Prescaler para o WDT fazendo com que o TIMER0 fique 1:1
	bsf			INTCON,T0IE			;Habilita a interrupção do TMR0
	bsf			INTCON, PEIE		;Habilita as interrupções dos periféricos.
	bsf			INTCON,GIE			;Ativa as interrupções

	BANK0
	bsf			LED_OERR			;Inicia o programa com o led setado (apagado) para OK


;Fim do Meu setup

;****************************************************************************
;*							INICIALIZAÇÃO DAS VARIÁVEIS						*
;****************************************************************************

	movlw		.0
	movwf		CONTADORLED_OERR	;Inicializa o contador do LED_OERR

;****************************************************************************
;*							CORPO DA ROTINA PRINCIPAL						*
;****************************************************************************

MAIN
	;CORPO DA ROTINA PRINCIPAL

	movlw		B'10101010'		;Carrega a memória RAM com esse valor
	movwf		0x22			;para eu poder testar as rotinas de leitura/escrita de bit
								;no pino definido por saida.
	movwf		PORTA
	movlw		.2				;Carrega o W com o valor necessário
								;para a lógica do PCL.

bit00
	SAIDABIT 0x22,0x23,8,bit00
bit0
	btfss		0x22,0
	addwf		PCL,1
	bsf			saida
	goto		proximo_bit
	bcf			saida
	nop
	nop

proximo_bit
	btfss		0x22,1
	addwf		PCL,1
	bsf			saida
	goto		proximo_bit
	bcf			saida
	nop
	nop

	GOTO 		MAIN

;****************************************************************************
;*							FIM DO PROGRAMA									*
;****************************************************************************


	END							;INDICA O FIM DO ARQUIVO CÓDIGO-FONTE
	

;Modelo de estruturação de códido baseado no exemplo do livro "Desbravando o PIC"
